# Реализация модального окна

Как вы думаете, сколько JS кода нужно, чтобы реализовать доступную карусель, которая будет закрываться на Esc, по клику на оверлей?  
Что, если я скажу, что всего 18 символов и те можно написать прям в html?

Не верите? [Вот демо](https://codepen.io/klekovvlad/pen/pvjQoBO)  
Эту задачу отлично решает html-элемент ```<dialog>```. Выше я говорил о нескольких символов JS для модалки - они тут:
```onclick="dialog.showModal()```
Тут мы говорим браузеру открыть модалку с идентификатором ```dialog```.   

Больше нам JS не нужен. Если мы передадим атрибут ```closedby="any"```, то она будет закрываться и по нажатию клавиши ```Esc``` и по клику вне области самого диалога.  
Если вы открыли демо и увидели странную форму с методом ```dialog```, не удивляйтесь, такой метод действительно сущетсвует и сабмит этой формы - закрывает диалог)    

А что по красоте?  
Мы можем стилизовать и бэкдроп самого диалога, для этого у нас есть псевдоэлемент ```::backdrop```  
И сам элемент, а еще можем добавить красивых анимаций, если обратимся к псевдокласу ```:open``` и стилизуем анимации через него    

Поддержка элемента широчайшая
![img_3.png](img_3.png)

По итогу мы получаем с минимальным колчеством JS нативное, широкоподдерживаемое и доступное модальное окно
 

# Оптимизация загрузки изображений



# Реализация карусели

Речь пойдет не о сложной реализации карусели, как вы привыкли видеть ее в том же [Swiper](https://www.npmjs.com/package/swiper)
с красивыми эффектами и всевозможными оптимизациями.  
Если вы спросите у заказчика, чего он хочет, а в ответ слышите, что-то похожее: "Хочу карусельку, чтобы с телефона пальцем свайпать, а она красиво скроллилась и прилипала",
то данный параграф будет вам полезен

Реализовать похожее поведение можно несколькими строчками CSS кода. Да и плюсов больше, чем минусов:
1. нет загрузки лишних ресурсов (речь о библиотеке с каруселью)
2. вы свободны в верстке, можете вставить, что угодно
3. вы можете сделать карусель доступной

```css
  .wrapper {
    overflow-x: auto;
    overscroll-behavior-x: contain;
    scroll-snap-type: x mandatory;
  }

  .item {
    scroll-snap-align: start;  
  }
```

[Демо](https://codepen.io/klekovvlad/pen/GgpYOpo). Основная "магия" заключается в свойстве ```scroll-snap-type```, значение ```x mandatory``` говорит:
"Сколь по оси X и прилипай, когда дойдешь до левого края", а ```scroll-snap-align```, говорит "Прилипай по левому краю"
  
В большинстве случаев, такая реализация может полностью покрыть требования заказчика.
При необходимости, можно насыпать немного JS и добавить "зацикленность", "сколл по кнопкам" и другие фичи. [Пример библиотеки](https://barthy-koeln.github.io/scroll-snap-slider/)

Поддержка более чем приятная - хоть завтра в прод!
![img.png](img.png)

# Реализация светлой и темной темы

Если раньше разработчики для переключение светлой и темной темы использовали дополнительные классы и добавляли его, например, в body, чтобы переопределить стили (надеюсь, они уже пользовались css переменными), то теперь для реализации
этой задачи нам отлично подходит относительно новая функция в css light-dark().

Функция имеет хорошую поддержку и работает во всех современных браузерах
![img_4.png](img_4.png)

Для реализации тем нам нужно указать для псевдокласа ```:root``` свойство ```color-scheme``` (у него, кстати. поддержка еще лучше)
![img_5.png](img_5.png)

```css
:root {
    color-scheme: light dark;
}
```

И чтобы это еще работало, нам нужно указать css переменные, как раз тут и используется функция ```light-dark()```

```css
:root {
    color-scheme: light dark;
    --text-color: light-dark(#000000, #FFFFFF);
    --background-color: light-dark(#FFFFFF, #000000)
}
```

Этого, в целом достаточно, используя такую конструкцию браузер будет автоматически использовать системную тему пользоваля и применять ее к вашему веб-приложению. Но нам же нужно уметь еще и переключать эти темы? 
Для переключения тем нам нужно оставить для родителя нужную нам ````color-scheme````

Возможно, вы подумаете, что вам понадобится JS, но тут тоже он не нужен, если вы знаете про псевдокласс ```:has``` (о нем еще будет упоминаться в данной статье). [Демо](https://codepen.io/klekovvlad/pen/zxvMRKN)



# Реализация popover

# Реализация аккордеона

# Реализация якорных ссылок

Бывали задачи, что вам нужно плавно доскроллить до элемента, кликнув по ссылке?
Я, надеюсь, что в реализации этой задачи вы уже использовали якорные ссылки и ```scroll-behavior: smooth```
```css
    html {
        scroll-behavior: smooth;
    }   
```

```html
    <a href="#anchor">Ссылка</a>
    <div id="anchor">Элемент</div>
```
Но вот незадача, сверху нависла sticky-шапка и она перекрывает контент.
Возможно, вы решите, что стандартные якорные ссылки уже не подходят и нужно решать задачу иначе - считать сколько до элемента, получать высоту хедера и скроллить до него?
Но что, если я скажу на это
```css
    .item {
        scroll-margin-top: 60px
    }   
```
[Демо](https://codepen.io/klekovvlad/pen/PwPxooP) Да, одно это свойство решает проблему sticky-шапки и недосколливает нужное количество пикселей
 
Поддержка тоже отличная, если у вас еще не осталось пользователь на IE11
![img_1.png](img_1.png)
![img_2.png](img_2.png)

# Реализация тултипа

Допустим, ваш заказчик хочет простой тултип, чтобы при наведении мышкой на какой-то элемент всплывала подсказка. Тоже полезли искать метод, который будет рассчитывать координаты и вешать на элемент onMouseEnter?  
А что, если реализовать и эту задачу только через css? Мы даже не будем использовать лишних элементов.
[Демо](https://codepen.io/klekovvlad/pen/ZYbmYNb).

Основная магия - использование псевдоэлемента ```:after``` с атрибутом ```data-tooltip``` (имя вы можете дать любое), да, в свойстве ```content``` может быть не только пустая строка, как вы привыкли использовать, а еще в него можно передать значения атрибута. который по-умолчанию скрыт, но при наведении на родителя показывается. Ховер продолжает работать даже, если пользователь переместит курсор на сам тултип. Стилизовать вы можете это как угодно. Такое решение отлично подходит для создания простых тултипов с подсказками

# Реализация switch-переключателя

Не самая частая задача, но которая тоже может вылиться в некоторые проблемы для разработчика. Нам нужно реализовать доступный элемент, без использования кучи ```<div>``` и самое главное - чтобы это работало (на момент написания статьи Switch в AntDesign 5.27.1 до сих пор является кнопкой внутри который куча html элементов). Чтобы найти легкое решение для этой задачи нужно представить на что из стандартных html элементов похож switch? Очевидно, что обычный чекбокс, у которого есть состояние включить/выключить.  

Но, насколько мы знаем, было достаточно сложно или практически невозможно стилизовать дефолтный чекбокс. Или все же ключевое слово БЫЛО и стилизовать теперь можно и его [Демо](https://codepen.io/klekovvlad/pen/myeQJVz).

Основной для реализации похожих элементов является относительно новое свойство ```apperance```, которая отключает дефолтные стили и позволяет стилизировать элемент, так, как хочет того заказчик (или ваше сердце).

# Реализация прогресса скролла
Я уверен, что вы знакомы со свойством ```animation``` в CSS и даже как-то использовали его для анимирования каких-либо элементов.
Вы уже привыкли, что нужно задать имя анимации, задержку и время выполнения анимации, но что, если я скажу, что таймлайном анимации может быть сколл? И это функция.. Все еще не верите, что CSS - язык програмирования?
  
```css
    .item {
      animation-timeline: scroll();
    }
```

В этом случае временем анимации является не просто секунды или любой другой временной отрезок, а насколько вы прокрутили элемент. 

Тут мы реализовали на чистом css прогресс. [Демо](https://codepen.io/klekovvlad/pen/VYvVwKo)

Кстати, помимо скролла таймлайном может быть так же функция ```view()```, но это уже работает по-другому. View-timeline привязывается не к скроллу, а к тому, насколько элемент находится во вьюпорте, согласитесь, отличное решение для реализации анимаций?

# Источники

* [MDN. appearance](https://developer.mozilla.org/en-US/docs/Web/CSS/appearance)
* [MDN. Dialog](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/dialog)
* [MDN. view-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/view-timeline)
* [MDN. animation-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline)
* [Building a media scroller component](https://web.dev/articles/building/a-media-scroller-component?hl=ru)
* [Никита Дубко — CSS first. Когда JS не нужен](https://www.youtube.com/watch?v=G_GwPX6hM9M)
* [Руки прочь от HTML-программистов!](https://youtu.be/Z_8s7hV7GlI?si=yHOhjugdNGa-riqS)
* [MDN. light-dark](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark)
