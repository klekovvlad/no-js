# Реализация модального окна

Как вы думаете, сколько JS кода нужно, чтобы реализовать доступную карусель, которая будет закрываться на Esc, по клику на оверлей?  
Что, если я скажу, что всего 18 символов и те можно написать прям в html?

Не верите? [Вот демо](https://codepen.io/klekovvlad/pen/pvjQoBO)  
Эту задачу отлично решает html-элемент ```<dialog>```. Выше я говорил о нескольких символов JS для модалки - они тут:
```onclick="dialog.showModal()```
Тут мы говорим браузеру открыть модалку с идентификатором ```dialog```.   

Больше нам JS не нужен. Если мы передадим атрибут ```closedby="any"```, то она будет закрываться и по нажатию клавиши ```Esc``` и по клику вне области самого диалога.  
Если вы открыли демо и увидели странную форму с методом ```dialog```, не удивляйтесь, такой метод действительно сущетсвует и сабмит этой формы - закрывает диалог)    

А что по красоте?  
Мы можем стилизовать и бэкдроп самого диалога, для этого у нас есть псевдоэлемент ```::backdrop```  
И сам элемент, а еще можем добавить красивых анимаций, если обратимся к псевдокласу ```:open``` и стилизуем анимации через него    

Поддержка элемента широчайшая
![img_3.png](img_3.png)

По итогу мы получаем с минимальным колчеством JS нативное, широкоподдерживаемое и доступное модальное окно
 

# Оптимизация загрузки изображений



# Реализация карусели

Речь пойдет не о сложной реализации карусели, как вы привыкли видеть ее в том же [Swiper](https://www.npmjs.com/package/swiper)
с красивыми эффектами и всевозможными оптимизациями.  
Если вы спросите у заказчика, чего он хочет, а в ответ слышите, что-то похожее: "Хочу карусельку, чтобы с телефона пальцем свайпать, а она красиво скроллилась и прилипала",
то данный параграф будет вам полезен

Реализовать похожее поведение можно несколькими строчками CSS кода. Да и плюсов больше, чем минусов:
1. нет загрузки лишних ресурсов (речь о библиотеке с каруселью)
2. вы свободны в верстке, можете вставить, что угодно
3. вы можете сделать карусель доступной

```css
  .wrapper {
    overflow-x: auto;
    overscroll-behavior-x: contain;
    scroll-snap-type: x mandatory;
  }

  .item {
    scroll-snap-align: start;  
  }
```

[Демо](https://codepen.io/klekovvlad/pen/GgpYOpo). Основная "магия" заключается в свойстве ```scroll-snap-type```, значение ```x mandatory``` говорит:
"Сколь по оси X и прилипай, когда дойдешь до левого края", а ```scroll-snap-align```, говорит "Прилипай по левому краю"
  
В большинстве случаев, такая реализация может полностью покрыть требования заказчика.
При необходимости, можно насыпать немного JS и добавить "зацикленность", "сколл по кнопкам" и другие фичи. [Пример библиотеки](https://barthy-koeln.github.io/scroll-snap-slider/)

Поддержка более чем приятная - хоть завтра в прод!
![img.png](img.png)

# Реализация светлой и темной темы

# Реализация popover

# Реализация аккордеона

# Реализация якорных ссылок

Бывали задачи, что вам нужно плавно доскроллить до элемента, кликнув по ссылке?
Я, надеюсь, что в реализации этой задачи вы уже использовали якорные ссылки и ```scroll-behavior: smooth```
```css
    html {
        scroll-behavior: smooth;
    }   
```

```html
    <a href="#anchor">Ссылка</a>
    <div id="anchor">Элемент</div>
```
Но вот незадача, сверху нависла sticky-шапка и она перекрывает контент.
Возможно, вы решите, что стандартные якорные ссылки уже не подходят и нужно решать задачу иначе - считать сколько до элемента, получать высоту хедера и скроллить до него?
Но что, если я скажу на это
```css
    .item {
        scroll-margin-top: 60px
    }   
```
[Демо](https://codepen.io/klekovvlad/pen/PwPxooP) Да, одно это свойство решает проблему sticky-шапки и недосколливает нужное количество пикселей
 
Поддержка тоже отличная, если у вас еще не осталось пользователь на IE11
![img_1.png](img_1.png)
![img_2.png](img_2.png)

# Реализация прогресса скролла
Я уверен, что вы знакомы со свойством ```animation``` в CSS и даже как-то использовали его для анимирования каких-либо элементов.
Вы уже привыкли, что нужно задать имя анимации, задержку и время выполнения анимации, но что, если я скажу, что таймлайном анимации может быть сколл? И это функция.. Все еще не верите, что CSS - язык програмирования?
  
```css
    .item {
      animation-timeline: scroll();
    }
```

В этом случае временем анимации является не просто секунды или любой другой временной отрезок, а насколько вы прокрутили элемент. 

Тут мы реализовали на чистом css прогресс. [Демо](https://codepen.io/klekovvlad/pen/VYvVwKo)

Кстати, помимо скролла таймлайном может быть так же функция ```view()```, но это уже работает по-другому. View-timeline привязывается не к скроллу, а к тому, насколько элемент находится во вьюпорте, согласитесь, отличное решение для реализации анимаций?

# Источники

* [MDN. Dialog](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/dialog)
* [MDN. view-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/view-timeline)
* [MDN. animation-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline)
* [Building a media scroller component](https://web.dev/articles/building/a-media-scroller-component?hl=ru)
* [Никита Дубко — CSS first. Когда JS не нужен](https://www.youtube.com/watch?v=G_GwPX6hM9M)
