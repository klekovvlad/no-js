# Вступление

Как часто вы интересуетесь современными возможностями CSS и HTML? Или решили, что нового там ничего не придумать или это не работает в браузерах? Те времена уже давно ушли и действительно можно начинать называть HTML и CSS языками программирования. Я надеюсь, после этого сообщения в ваш монитор не полетел тапок и вы не побежали писать гневный комментарий. 

На написание этой статьи меня подтолкнуло наличие большого количества информации и современном CSS, его относительно новым фишкам (к моменту написания статья которым уже более 2-х лет), но о которых знают немногие. Мы привыкли использовать готовые решения или ```tailwind css``` и боимся смотреть в будущее.

Данная статья - компиляция различных источников и предоставление ее в текстовом и более сжатом виде.

# Реализация модального окна

Как вы думаете, сколько JS кода нужно, чтобы реализовать доступную карусель, которая будет закрываться на Esc, по клику на оверлей?  
Что, если я скажу, что всего 18 символов и те можно написать прям в html?

Не верите? [Вот демо](https://codepen.io/klekovvlad/pen/pvjQoBO)  
Эту задачу отлично решает html-элемент ```<dialog>```. Выше я говорил о нескольких символов JS для модалки - они тут:
```onclick="dialog.showModal()```
Тут мы говорим браузеру открыть модалку с идентификатором ```dialog```.   

Больше нам JS не нужен. Если мы передадим атрибут ```closedby="any"```, то она будет закрываться и по нажатию клавиши ```Esc``` и по клику вне области самого диалога.  
Если вы открыли демо и увидели странную форму с методом ```dialog```, не удивляйтесь, такой метод действительно сущетсвует и сабмит этой формы - закрывает диалог)    

А что по красоте?  
Мы можем стилизовать и бэкдроп самого диалога, для этого у нас есть псевдоэлемент ```::backdrop```  
И сам элемент, а еще можем добавить красивых анимаций, если обратимся к псевдокласу ```:open``` и стилизуем анимации через него    

Поддержка элемента широчайшая
![img_3.png](img_3.png)

По итогу мы получаем с минимальным колчеством JS нативное, широкоподдерживаемое и доступное модальное окно
 

# Оптимизация загрузки изображений

Предположим, что перед вами стоит задача сделать страницу с галереей изображений. Заказчик хочет показать на странице все две тысячи его классных фотографий. Как поступить, чтобы пользователю не загружать сразу такой большой объем данных?

Если вы знакомы с реализацией виртуальынх списков через подписку на скролл или того лучше - браузерным API ```Intersection Observer API```, то это отлично, но требует кода на JS, а статья как раз о том, чтобы его избежать.

У ```img``` и ```iframe``` тегов доступен атрибут ```loading```, если в него указать значение ```lazy```, то браузер самостоятельно определит, находится ли изображение во вьюпорте и загрузит при необходимости. 

```
<img src="https://example.com/image.png" loading="lazy" />
```

Это, все, нам даже не потребуется css. Поддержка широкая, можно использовать в продакшене.
![img_7.png](img_7.png)


# Реализация карусели

Речь пойдет не о сложной реализации карусели, как вы привыкли видеть ее в том же [Swiper](https://www.npmjs.com/package/swiper)
с красивыми эффектами и всевозможными оптимизациями.  
Если вы спросите у заказчика, чего он хочет, а в ответ слышите, что-то похожее: "Хочу карусельку, чтобы с телефона пальцем свайпать, а она красиво скроллилась и прилипала",
то данный параграф будет вам полезен

Реализовать похожее поведение можно несколькими строчками CSS кода. Да и плюсов больше, чем минусов:
1. нет загрузки лишних ресурсов (речь о библиотеке с каруселью)
2. вы свободны в верстке, можете вставить, что угодно
3. вы можете сделать карусель доступной

```css
  .wrapper {
    overflow-x: auto;
    overscroll-behavior-x: contain;
    scroll-snap-type: x mandatory;
  }

  .item {
    scroll-snap-align: start;  
  }
```

[Демо](https://codepen.io/klekovvlad/pen/GgpYOpo). Основная "магия" заключается в свойстве ```scroll-snap-type```, значение ```x mandatory``` говорит:
"Сколь по оси X и прилипай, когда дойдешь до левого края", а ```scroll-snap-align```, говорит "Прилипай по левому краю"
  
В большинстве случаев, такая реализация может полностью покрыть требования заказчика.
При необходимости, можно насыпать немного JS и добавить "зацикленность", "сколл по кнопкам" и другие фичи. [Пример библиотеки](https://barthy-koeln.github.io/scroll-snap-slider/)

Поддержка более чем приятная - хоть завтра в прод!
![img.png](img.png)

# Реализация светлой и темной темы

Если раньше разработчики для переключение светлой и темной темы использовали дополнительные классы и добавляли его, например, в body, чтобы переопределить стили (надеюсь, они уже пользовались css переменными), то теперь для реализации
этой задачи нам отлично подходит относительно новая функция в css light-dark().

Функция имеет хорошую поддержку и работает во всех современных браузерах
![img_4.png](img_4.png)

Для реализации тем нам нужно указать для псевдокласа ```:root``` свойство ```color-scheme``` (у него, кстати. поддержка еще лучше)
![img_5.png](img_5.png)

```css
:root {
    color-scheme: light dark;
}
```

И чтобы это еще работало, нам нужно указать css переменные, как раз тут и используется функция ```light-dark()```

```css
:root {
    color-scheme: light dark;
    --text-color: light-dark(#000000, #FFFFFF);
    --background-color: light-dark(#FFFFFF, #000000)
}
```

Этого, в целом достаточно, используя такую конструкцию браузер будет автоматически использовать системную тему пользоваля и применять ее к вашему веб-приложению. Но нам же нужно уметь еще и переключать эти темы? 
Для переключения тем нам нужно оставить для родителя нужную нам ````color-scheme````

Возможно, вы подумаете, что вам понадобится JS, но тут тоже он не нужен, если вы знаете про псевдокласс ```:has``` (о нем еще будет упоминаться в данной статье). [Демо](https://codepen.io/klekovvlad/pen/zxvMRKN)

# Ограничение текста

Обрезать текст и поставить многоточние, если текст длинный, частая задача при разработке веб-интерфейсов. Многие разработчики для решения этой задачи использовали JS, обрезая строку на n-количество символов, но было сложно добиться на различных разрешениях экрана ровных не рваных по-середине или в начале строк. Для реализации этой задачи нам потребуется так же всего 4 строчки css кода

```css
.text {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient:vertical;  
  overflow: hidden;
}
```

Поддержка свойства составляет на момент написания статьи более 95%
![img_6.png](img_6.png)

Но, что, если нам нужено не просто обрезать текст, но и уметь его раскрыть полностью, еще и менять лейбл кнопки, которая раскрывает или скрывает текст? Тут тоже нам не потребуется JS, выше я упоминал о псевдоклассе ```:has```
.   

Изначально мы так же обрезаем текст стилями выше, но добавляем в верстку так же чекбокс

```html
    <div class="clamp-toggle">
      <p>В европейских странах вопрос о здоровом питании был поднят давно, и в немецкой, французской, итальянской, греческой кухнях представлено большое количество блюд, которые смело можно отнести к полезной пище. У каждого, кто любит возиться на кухне, есть масса маленьких секретов, которые доводят простые блюда до совершенства. Учеными было потрачено много лет, чтобы установить, какие продукты и когда нужно есть, чтобы всегда быть стройным и здоровыми. Прежде всего стоит сказать, что люди часто путают диетическую и обезжиренную пищу с полезной.</p>
      <label>
        <input type="checkbox" />
      </label>
    </div>
```

Все, что нужно - добавить эти стили

```css
.clamp-toggle p {
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient:vertical;  
  overflow: hidden;
}

.clamp-toggle input[type=checkbox] {
  display: none;
}

.clamp-toggle label::after {
  content: 'Раскрыть'
}

.clamp-toggle:has(input[type=checkbox]:checked) p {
  display: block;
}

.clamp-toggle:has(input[type=checkbox]:checked) label::after {
  content: 'Скрыть'
}
```

По-умолчанию мы скрываем чекбокс и через псевдоэлемент задаем текст для ```label```, эта конструкция ```.clamp-toggle:has(input[type=checkbox]:checked)``` говорит дословно браузеру - "Если внутри элемента есть чекбокс, который выбран, примени стили ниже", так мы и меняем текст для лейбла и стили для текста. [Демо](https://codepen.io/klekovvlad/pen/vENQdpV)

# Реализация popover

# Реализация аккордеона

# Реализация якорных ссылок

Бывали задачи, что вам нужно плавно доскроллить до элемента, кликнув по ссылке?
Я, надеюсь, что в реализации этой задачи вы уже использовали якорные ссылки и ```scroll-behavior: smooth```
```css
    html {
        scroll-behavior: smooth;
    }   
```

```html
    <a href="#anchor">Ссылка</a>
    <div id="anchor">Элемент</div>
```
Но вот незадача, сверху нависла sticky-шапка и она перекрывает контент.
Возможно, вы решите, что стандартные якорные ссылки уже не подходят и нужно решать задачу иначе - считать сколько до элемента, получать высоту хедера и скроллить до него?
Но что, если я скажу на это
```css
    .item {
        scroll-margin-top: 60px
    }   
```
[Демо](https://codepen.io/klekovvlad/pen/PwPxooP) Да, одно это свойство решает проблему sticky-шапки и недосколливает нужное количество пикселей
 
Поддержка тоже отличная, если у вас еще не осталось пользователь на IE11
![img_1.png](img_1.png)
![img_2.png](img_2.png)

# Реализация тултипа

Допустим, ваш заказчик хочет простой тултип, чтобы при наведении мышкой на какой-то элемент всплывала подсказка. Тоже полезли искать метод, который будет рассчитывать координаты и вешать на элемент onMouseEnter?  
А что, если реализовать и эту задачу только через css? Мы даже не будем использовать лишних элементов.
[Демо](https://codepen.io/klekovvlad/pen/ZYbmYNb).

Основная магия - использование псевдоэлемента ```:after``` с атрибутом ```data-tooltip``` (имя вы можете дать любое), да, в свойстве ```content``` может быть не только пустая строка, как вы привыкли использовать, а еще в него можно передать значения атрибута. который по-умолчанию скрыт, но при наведении на родителя показывается. Ховер продолжает работать даже, если пользователь переместит курсор на сам тултип. Стилизовать вы можете это как угодно. Такое решение отлично подходит для создания простых тултипов с подсказками

# Реализация switch-переключателя

Не самая частая задача, но которая тоже может вылиться в некоторые проблемы для разработчика. Нам нужно реализовать доступный элемент, без использования кучи ```<div>``` и самое главное - чтобы это работало (на момент написания статьи Switch в AntDesign 5.27.1 до сих пор является кнопкой внутри который куча html элементов). Чтобы найти легкое решение для этой задачи нужно представить на что из стандартных html элементов похож switch? Очевидно, что обычный чекбокс, у которого есть состояние включить/выключить.  

Но, насколько мы знаем, было достаточно сложно или практически невозможно стилизовать дефолтный чекбокс. Или все же ключевое слово БЫЛО и стилизовать теперь можно и его [Демо](https://codepen.io/klekovvlad/pen/myeQJVz).

Основной для реализации похожих элементов является относительно новое свойство ```apperance```, которая отключает дефолтные стили и позволяет стилизировать элемент, так, как хочет того заказчик (или ваше сердце).

# Реализация прогресса скролла
Я уверен, что вы знакомы со свойством ```animation``` в CSS и даже как-то использовали его для анимирования каких-либо элементов.
Вы уже привыкли, что нужно задать имя анимации, задержку и время выполнения анимации, но что, если я скажу, что таймлайном анимации может быть сколл? И это функция.. Все еще не верите, что CSS - язык програмирования?
  
```css
    .item {
      animation-timeline: scroll();
    }
```

В этом случае временем анимации является не просто секунды или любой другой временной отрезок, а насколько вы прокрутили элемент. 

Тут мы реализовали на чистом css прогресс. [Демо](https://codepen.io/klekovvlad/pen/VYvVwKo)

Кстати, помимо скролла таймлайном может быть так же функция ```view()```, но это уже работает по-другому. View-timeline привязывается не к скроллу, а к тому, насколько элемент находится во вьюпорте, согласитесь, отличное решение для реализации анимаций?

# Заключение

Итог этой статьи прост - интересуйтесь новым и пробуйте новое. Используйте инструмент по-назначению.

# Источники

* [MDN. Lazy loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/Lazy_loading)
* [MDN. appearance](https://developer.mozilla.org/en-US/docs/Web/CSS/appearance)
* [MDN. Dialog](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/dialog)
* [MDN. view-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/view-timeline)
* [MDN. animation-timeline](https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timeline)
* [Building a media scroller component](https://web.dev/articles/building/a-media-scroller-component?hl=ru)
* [Никита Дубко — CSS first. Когда JS не нужен](https://www.youtube.com/watch?v=G_GwPX6hM9M)
* [Руки прочь от HTML-программистов!](https://youtu.be/Z_8s7hV7GlI?si=yHOhjugdNGa-riqS)
* [MDN. light-dark](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/light-dark)
